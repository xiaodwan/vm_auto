import time
import inspect
import unittest

# set to vmmlogger in order to prevent coding modifying 
# when we want to implement our own log module 
# Now we use log function by dogtail
from dogtail.logging import debugLogger as vmmlogger

from utils.dogtailutils import *
from utils.vmcheck import *

#DEFAULT_TREE = "http://download.eng.pek2.redhat.com/pub/rhel/released/RHEL-7/7.3/Server/x86_64/os/"
#DEFAULT_KICKSTART = "ks=http://fileshare.englab.nay.redhat.com/pub/section3/run/http-ks/ks-rhel7u3-x86_64.cfg"
#GUEST_NAME = "rhel7.3_autotest"
#OS_VERSION = "Red Hat Enterprise Linux 7.3"  # should be 7.3
#DEFAULT_URI = "qemu:///system"

def get_current_function_name():
        return inspect.stack()[1][3]


class vmmApp(DogtailApp):
    """
    The Virtual Machine Manager main window
    """
    def select_connection(self, connction_name):
       find_pattern(self.root, connction_name, "table cell").click()

    # some default installation operation for creating new vm
    def create_new_vm_url(self, guestname=None, url=None, ks=None, pingflag=True):
        res = False

        newvm_wizard = vmmAddNewVM(self)
        newvm_wizard.open_create_wizard(self.root)

        find_fuzzy(newvm_wizard.rootwindow, "Network Install", "radio").click()
        find_fuzzy(newvm_wizard.rootwindow, "Forward", "button").click()

        if url is None or ks is None:
            vmmlogger.log("Error: url or ks is None")
            return res


        find_pattern(newvm_wizard.rootwindow, None, "text", "URL").typeText(url)
        # type kickstart into kernel options for auto installation
        # toggle button click doesn't work, so user keyCombo instead
        # uiutils.find_pattern(newvm_wizard, "URL Options", "toggle button").click()
        newvm_wizard.rootwindow.keyCombo('<Alt>o')
        find_pattern(newvm_wizard.rootwindow, None, 
                     "text", "Kernel options").typeText(ks)
            

        # auto detect will begin after clicking Forward button
        find_fuzzy(newvm_wizard.rootwindow, "Forward", "button").click()

        version = find_pattern(newvm_wizard.rootwindow, "install-os-version-label")
        time.sleep(1)
        check_in_loop(lambda: "Detecting" not in version.text 
                      and "-" not in version.text)

        find_fuzzy(newvm_wizard.rootwindow, "Forward", "button").click()
        find_fuzzy(newvm_wizard.rootwindow, "Forward", "button").click()

        # use default name which generated by virt-manager
        if guestname is not None:
            find_pattern(newvm_wizard.rootwindow, None, "text", "Name").typeText(guestname)
        else:
            guestname = find_pattern(newvm_wizard.rootwindow, None, "text", "Name").text

        find_fuzzy(newvm_wizard.rootwindow, "Finish", "button").click()

        progress = find_fuzzy(self.root,
                                "Creating Virtual Machine", "frame")
        # waiting 5 mins, if timeout, maybe a network problem
        check_in_loop(lambda: not progress.showing, 300)
        time.sleep(.5)

        find_fuzzy(self.root, guestname +" on", "frame")
        
        if self.pid is not None:
            # waiting vm installation complete
            res = check_vm_install_complete(self.pid, guestname)

        # check ping to guest, this only works for qemu:///system
        if pingflag is True:
            res = ping_vm(guestname)

        vmmlogger.log("Install (%s) finished with ping result: %s" % (guestname, str(res)))
        return res

    def create_new_vm_cdrom(self, cdrom=None, ks=None):
        pass

    def create_new_vm_import(self, imagefile=None):
        pass

class vmmAddNewPool(object):
    """
    Add New Pool
    """

    def __init__(self, app):
        self.root = app.root
        self._rootwindow = None

    @property
    def rootwindow(self): 
        if self._rootwindow is None:
            try:
                self._rootwindow = find_pattern(self.root, "Add a New Storage Pool", "frame")
            except:
                vmmlogger.log("Failed to set property: %s in vmmAddNewPool" % "rootwindow")
                raise

        return self._rootwindow


class vmmAddNewVM(object):        

    def __init__(self, app):
        self.root = app.root
        self._rootwindow = None

    @property
    def rootwindow(self): 
        if self._rootwindow is None:
            try:
                self._rootwindow = find_pattern(self.root, "New VM", "frame")
            except:
                vmmlogger.log("Failed to set property: %s in vmmAddNewVM" % "rootwindow")
                raise
        return self._rootwindow

    def open_create_wizard(self, root):
        find_pattern(root, "New", "push button").click()

        return self.rootwindow



class vmmConnectionDetails(object):
    def __init__(self, app):
        self.root = app.root
        self._rootwindow = None

    @property
    def rootwindow(self): 
        if self._rootwindow is None:
            try:
                #print_nodes(self.root)
                self._rootwindow = find_pattern(self.root, ".* Connection Details", "frame")
            except:
                vmmlogger.log("Failed to set property: %s in vmmConnectionDetails" % "rootwindow")
                raise
        return self._rootwindow

    def open_connection_details(self):
	find_pattern(self.root, "Edit","menu").click()
	find_pattern(self.root, "Connection Details","menu item").click()

        return self.rootwindow

    def close_connection_details(self):

        find_pattern(self.rootwindow, "File", "menu").click()
        find_pattern(self.rootwindow, "Close", "menu item").click()

    def add_pool_type_dir(self, root, poolname):
        """
        @root: the parent window of "Add a New Storage Pool"
        """
        selecttab(root, "Storage")

	find_pattern(root, "","push button", "", "Add Pool").click()
        # Need to find root node first
        #add_new_pool_win = find_pattern(findAncestor_pattern(root,"virt-manager"), 
        #                                "Add a New Storage Pool","frame")

        # get the root of "Add a New Storage Pool" window
        win_add_new_pool = find_pattern(self.root, "Add a New Storage Pool", "frame")

	find_pattern(win_add_new_pool, "","text", "Name").typeText(poolname)
	find_pattern(win_add_new_pool, "dir","combo box","Type").click()
        find_pattern(win_add_new_pool, "dir: Filesystem Directory","menu item").click()
        find_pattern(win_add_new_pool, "Forward","push button").click()
        find_pattern(win_add_new_pool, "Finish","push button").click()
        time.sleep(1)


    def del_pool(self, poolname):
        find_pattern(self.rootwindow, poolname, "table cell").click()
	find_pattern(self.rootwindow, "","push button", "", "Stop Pool").click()
        time.sleep(1)
	find_pattern(self.rootwindow, "","push button", "", "Delete Pool").click()
        time.sleep(1)
        self.rootwindow.keyCombo('<Alt>y')

    def get_pool_status_all(self, root, name):
        storagevol=[]
        storagename=[]
        
        # Select the testing pool first in order to get 
        # correct size of the testing pool
        find_pattern(root, name,"table cell").click()

        for i in findChildren_fuzzy(root,"","table cell"):
            if '%' in i.name:
                storagevol.append(i.name[:-1])
            elif i.name:
                storagename.append(i.name.split('\n')[0])

        # the last Autostart is for the testing pool
        storageautostart = findChildren_fuzzy(root, "", "check box", "Autostart")[-1].name
        storagelocation = find_fuzzy(root, name, "label").name
        storagesize = find_pattern(root, ".*Free.*In Use", "label").name.split()[0]

        return (storagename[storagename.index(name)], 
                storagevol[storagename.index(name)],
                storagelocation,
                storageautostart,
                storagesize)

    # Not necessary now
    #def get_pool_state(self, root, state):
    #    pass

    #def get_pool_autostart(self, root, autostart):
    #    pass

    #def get_pool_name(self, root, name):
    #    pass

    #def get_pool_size(self, root, size):
    #    pass

    #def get_pool_location(self, root, location):
    #    pass

class vmmPreferences(object):
    def __init__(self, app):
        self.root = app.root
        self._rootwindow = None

    @property
    def rootwindow(self): 
        if self._rootwindow is None:
            try:
                self._rootwindow = find_pattern(self.root, "Preferences", "frame")
            except:
                # will replace all print with logging functions
                vmmlogger.log("Failed to set property: %s" % "rootwindow")
                raise
        return self._rootwindow
    
    def open_preferences(self):

	find_pattern(self.root, "Edit","menu").click()
	find_pattern(self.root, "Preferences","menu item").click()

        return self.rootwindow

    def close_preferences(self):

        find_pattern(self.rootwindow, "Close", "push button").click()

    #def selecttab(self, tabname):
    #    try:
    #        find_pattern(self.rootwindow, tabname, "page tab").click()
    #    except:
    #        print_nodes(self.rootwindow)
    #        vmmlogger.log("Error: failed to select tab : %s in node [%s]" % tabname, self.rootwindow)
    #        raise

    def setconformation(self, name="" or "default", check=True, tabname="Feedback"):

        # Default settings 0: unchecked 1:checked
        conform_items = {
                            "Force Poweroff" : 0,
                            "Poweroff/Reboot/Save" : 0,
                            "Pause" : 0,
                            "Interface start/stop" : 1,
                            "Device removal" : 0,
                            "Unapplied changes" : 1,
                            "Deleting storage" : 0 
                        }

        # open preferences window and select feedback tab
        self.open_preferences()
        selecttab(self.rootwindow, tabname)

        # set to default value
        if name == "default":
            for key, value in conform_items.items():
                checkflag = 0

                confirm_checkbox = find_pattern(self.rootwindow, "", "check box", key)

                if confirm_checkbox.checked:
                    checkflag = 1
                if value != checkflag:
                    confirm_checkbox.click()
        # set to check value
        elif name in conform_items:
            confirm_checkbox = find_pattern(self.rootwindow, "", "check box", name)
            if confirm_checkbox.checked != check:
                confirm_checkbox.click()
        else:
            vmmlogger.log("Invalid confirmation item name: %s" % name)
    

# make it class independant?
def selecttab(root, tabname):
    try:
        find_pattern(root, tabname, "page tab").click()
    except:
        vmmlogger.log("Error: failed to select tab : %s in node [%s]" % tabname, root)
        raise

import traceback
def exception_log(e):
    bt = traceback.format_exc(e)
    vmmlogger.log(bt)


